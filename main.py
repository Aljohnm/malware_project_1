from fastapi import FastAPI, UploadFile, File, Request, HTTPException, status
from fastapi.responses import HTMLResponse
import json
import pandas as pd
from model import load_models
from motor.motor_asyncio import AsyncIOMotorClient
from sklearn.metrics import accuracy_score
from bson import ObjectId
from fastapi.templating import Jinja2Templates

app = FastAPI()

# Load pre-trained models
pipeline, label_encoder = load_models()

# Load the trained dataset
trained_data = pd.read_csv('malware_train_data.csv')

# MongoDB setup
client = AsyncIOMotorClient("mongodb://localhost:27017")
db = client['malware_detection_system']
collection = db['detection_logs']
user_questions = db['user_questions']

# Set up Jinja2 templates
templates = Jinja2Templates(directory="templates")

# Define the necessary numerical and categorical feature lists
numerical_features = [
    'File Size (KB)', 'Memory Usage (MB)', 'Battery Usage (%)', 'CPU Usage (%)',
    'Network Traffic (KB/s)', 'Process Count', 'Thread Count', 'I/O Read Rate (MB/s)',
    'I/O Write Rate (MB/s)', 'File Creation Time (Days ago)', 'Last Access Time (Days ago)',
    'File Entropy', 'System Calls per Second', 'Registry Changes Count', 'File Modifications Count',
    'Error Log Count', 'Warning Log Count'
]

categorical_features = [
    'Source IP', 'Destination IP', 'Protocol', 'Admin Privileges Used', 'File Write Permissions'
]

@app.get("/", response_class=HTMLResponse)
async def root():
    """Display the index page with a button to navigate to the admin dashboard."""
    return HTMLResponse(content="""
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Malware Detection System</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        body {
            background-color: #f8f9fa;
            font-family: Arial, sans-serif;
            height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dashboard-container {
            background-color: #ffffff;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 100%;
            max-width: 600px;
        }

        h1 {
            color: #343a40;
            margin-bottom: 30px;
            font-weight: 600;
        }

        p {
            margin-bottom: 40px;
            font-size: 1.1rem;
            color: #6c757d;
        }

        .btn {
            width: 100%;
            padding: 15px;
            font-size: 1.2rem;
        }

        .col-md-6 {
            padding-bottom: 20px;
        }

        @media (max-width: 768px) {
            .dashboard-container {
                padding: 20px;
            }

            .btn {
                font-size: 1rem;
            }
        }
    </style>
</head>

<body>
    <div class="dashboard-container">
        <h1>Welcome to the Malware Detection System</h1>
        <p>Select one of the options below to continue</p>
        <div class="row">
            <div class="col-md-6">
                <a href="/admin_dashboard" class="btn btn-primary">Go to Admin Dashboard</a>
            </div>
            <div class="col-md-6">
                <a href="/user_dashboard" class="btn btn-success">Go to User Dashboard</a>
            </div>
        </div>
    </div>
</body>

</html>

    """)
    
# Route to display the Q&A page for answering questions
@app.get("/q_and_a", response_class=HTMLResponse)
async def q_and_a(request: Request):
    questions = await user_questions.find().to_list(length=None)  # Fetch all questions from MongoDB
    return templates.TemplateResponse("q_and_a.html", {"request": request, "questions": questions})

# Route to submit an answer to a question
@app.post("/answer_question/{question_id}")
async def answer_question(question_id: str, request: Request):
    """Submit an answer to a question."""
    data = await request.json()
    answer = data.get("answer")

    if not answer:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Answer is required")

    # Convert question_id to ObjectId for MongoDB lookup
    result = await user_questions.update_one({"_id": ObjectId(question_id)}, {"$set": {"answer": answer}})
    
    if result.modified_count == 0:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Question not found or already answered")
    
    return {"success": True}

@app.get("/admin_dashboard", response_class=HTMLResponse)
async def admin_dashboard():
    """Display the admin dashboard with aggregated data."""
    category_distribution = trained_data['Malware Type'].value_counts().to_dict()
    memory_usage = trained_data.groupby('Malware Type')['Memory Usage (MB)'].sum().to_dict()
    battery_usage = trained_data.groupby('Malware Type')['Battery Usage (%)'].sum().to_dict()
    network_usage = trained_data.groupby('Malware Type')['Network Traffic (KB/s)'].sum().to_dict()
    
    # Create a summary for the trained dataset
    trained_summary = {
        "category_distribution": category_distribution,
        "memory_usage": memory_usage,
        "battery_usage": battery_usage,
        "network_usage": network_usage,
    }
    
    # Pass this data to the HTML page
    with open("templates/admin_dashboard.html") as f:
        return HTMLResponse(content=f.read().replace("{{ trained_summary }}", json.dumps(trained_summary)))

# User Dashboard
@app.get("/user_dashboard", response_class=HTMLResponse)
async def user_dashboard():
    """Display the user dashboard."""
    return HTMLResponse(content=open("templates/user_dashboard.html").read())

# Route for the chatbot page
@app.get("/chatbot", response_class=HTMLResponse)
async def read_chatbot():
    """Display the chatbot page."""
    with open("templates/chatbot.html") as f:
        return HTMLResponse(content=f.read())

@app.get("/trained_dataset_summary/")
async def trained_dataset_summary():
    """Return a summary of the trained dataset."""
    global trained_data
    summary = {
        "category_distribution": trained_data['Malware Type'].value_counts().to_dict(),
        "memory_usage": trained_data.groupby('Malware Type')['Memory Usage (MB)'].sum().to_dict(),
        "battery_usage": trained_data.groupby('Malware Type')['Battery Usage (%)'].sum().to_dict(),
        "network_usage": trained_data.groupby('Malware Type')['Network Traffic (KB/s)'].sum().to_dict(),
    }
    return summary  # Return the summary as JSON

# Overview of Malware Page
@app.get("/overview_malware", response_class=HTMLResponse)
async def overview_malware():
    """Display the overview of malware page."""
    return HTMLResponse(content=open("templates/overview_malware.html").read())

# Risk Notification and Popup Page
@app.get("/risk_notification", response_class=HTMLResponse)
async def risk_notification():
    """Display the risk notification page."""
    return HTMLResponse(content=open("templates/risk_notification.html").read())

# Users Q&A Page
@app.get("/users_qa", response_class=HTMLResponse)
async def users_qa():
    """Display the users' Q&A page."""
    return HTMLResponse(content=open("templates/users_qa.html").read())

# Submit Question to MongoDB
@app.post("/submit_question", response_model=dict)
async def submit_question(request: Request):
    """Submit a question to MongoDB."""
    data = await request.json()
    question = data.get('question')
    
    if not question:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Question is required")

    # Save the question to MongoDB
    question_entry = {"question": question}
    await db['user_questions'].insert_one(question_entry)
    
    return {"success": True}
    
@app.get("/q_and_a", response_class=HTMLResponse)
async def q_and_a(request: Request):
    questions = await db.user_questions.find().to_list(length=None)  # Fetch all questions from the database
    return templates.TemplateResponse("q_and_a.html", {"request": request, "questions": questions})
    

# Function to evaluate accuracy and return incorrect predictions
def evaluate_accuracy(data, predictions):
    true_labels = data['Malware Type']  # Use the exact name from the uploaded file
    accuracy = accuracy_score(true_labels, predictions)
    incorrect_preds = data[true_labels != predictions]
    return accuracy, incorrect_preds

@app.post("/upload/", response_model=dict, summary="Upload a CSV file for malware prediction")
async def upload_file(file: UploadFile = File(...)):
    """
    Upload a CSV file containing malware data to predict the malware type, and get the resource usage breakdown.
    """
    try:
        data = pd.read_csv(file.file)  # Assume CSV format

        # Ensure the uploaded file contains necessary columns
        required_columns = numerical_features + categorical_features + ['Malware Type']
        
        # Check for missing required columns
        missing_columns = [col for col in required_columns if col not in data.columns]
        if missing_columns:
            return {"error": f"Missing required columns in the uploaded file: {', '.join(missing_columns)}"}

        # Use the loaded pipeline for predictions
        predictions = pipeline.predict(data[numerical_features + categorical_features])
        decoded_predictions = label_encoder.inverse_transform(predictions)

        # Evaluate accuracy and incorrect predictions
        accuracy, incorrect_preds = evaluate_accuracy(data, decoded_predictions)

        # Prepare incorrect predictions in structured format
        incorrect_preds_list = []
        for idx in incorrect_preds.index:
            incorrect_preds_list.append({
                "index": idx,
                "true_label": data.loc[idx, 'Malware Type'],  # Ensure 'Malware Type' matches your column
                "predicted_label": decoded_predictions[idx]
            })

        # Aggregating resource usage based on malware type
        category_distribution = data['Malware Type'].value_counts().to_dict()
        memory_usage = data.groupby('Malware Type')['Memory Usage (MB)'].sum().to_dict()
        battery_usage = data.groupby('Malware Type')['Battery Usage (%)'].sum().to_dict()
        network_usage = data.groupby('Malware Type')['Network Traffic (KB/s)'].sum().to_dict()

        # Log to MongoDB
        log = {
            "file_name": file.filename,  # Log the uploaded file's name
            "accuracy": accuracy,
            "incorrect_predictions": incorrect_preds_list,  # Use structured list here
            "category_distribution": category_distribution,
            "resource_usage": {
                "memory_usage": memory_usage,
                "battery_usage": battery_usage,
                "network_usage": network_usage
            }
        }
        await collection.insert_one(log)

        # Return the result as a response
        return {
            "accuracy": accuracy,
            "incorrect_predictions": incorrect_preds_list,  # Use structured list here
            "category_distribution": category_distribution,
            "memory_usage": memory_usage,
            "battery_usage": battery_usage,
            "network_usage": network_usage
        }

    except Exception as e:
        return {"error": str(e)}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
